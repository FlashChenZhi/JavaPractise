                                                线程中常见方法及其区别
一、Object 类的方法
1. wait()：  [等待线程]
   (1).作用：
   使其执行线程生命状态变为waiting，使其被暂停，可以实现等待；
   等待之后，只有这个对象又调用了notify()/notifyAll方法之后，这个等待线程才被唤醒
   (2).执行条件：
   需要持有对象someObject的内部锁才能执行，所以对象someOnject.wait()方法需要在该对象所引导的临界区内
   说明：保护条件、someObject.wait()、目标动作都应该在临界区内 ( 临界区：https://blog.csdn.net/u013272948/article/details/53929572 )

   对象的wait方法可能被不同的线程执行，所以同一个对象可能会有多个等待线程
   (3).当前线程执行someObject.wait()方法之后：
       <1>.释放someObject对象的内部锁   (为使notify()方法的线程获取当前对象的内部锁)
       <2>.然后将当前线程加入到与这个对象相关的等待集Wait Set  ( java虚拟机会为每个对象都维护一个等待集，用来存储这个对象上的等待线程 )
       <3>.wait()是原子操作的方法，当前线程被暂停后就不会往下执行，等待被唤醒，重新获取对象的内部锁，再重新判断条件往下执行；
           若判断条件不符合，还可能再次进入wait()方法，直到条件成立，执行完目标动作这个方法才算完成

2.notify() / notifyAll()： [通知线程]
    (1).作用：唤醒线程
        notify()方法是唤醒该对象相关的Wait Set的任意一个线程，notifyAll()方法是唤醒相关的所有线程
    (2).执行条件：
        需要持有对象someObject的内部锁才能执行，所以对象的someObject.notify() / notifyAll()方法需要在该对象所引导的临界区内
    (3).当前线程执行notify()/notifyAll()方法之后：
        <1>.执行notify之后，通知唤醒该对象相关的一个线程（notifyAll线程唤醒相关的所有线程），但此时还没释放对象的锁，所以其他线程只能等待;
            等到线程收到通知之后，没申请到对象的锁，此时还待在wait set等待集中
        <2>.直到这个临界区执行完，再释放对象的内部锁
        <3>.等待线程收到通知，并申请获得对象的锁之后，该等待线程会从该对象的wait set等待集中移除
    (4).注意：
        尽量让notify()靠近临界区结束的地方，免得等待线程因为没有获得对象的锁，而又进入等待状态

二、Thread 类的方法
1.join()方法： [挂起线程]
    (1).作用：当某个线程操作需要等待另一个线程执行完毕之后才能继续进行时，使用Join()方法
    (2).注意：该方法也需要捕捉异常
2.sleep()方法：
    (1).作用：给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会
    (2).结论：sleep()方法只能让当前线程睡眠   ( 调用某个线程类的对象t.sleep()，睡眠的不是t，而是当前线程 )
3.yield()方法：
    (1).作用：
        <1>.暂停当前正在执行的线程对象（及放弃当前拥有的cup资源），并执行其他线程
        <2>.让当前运行线程回到可运行状态，可使相同优先级的线程之间能适当的轮转执行
    (2).结论：yield()从未导致线程转到等待/睡眠/阻塞状态；多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能无效果

三、run()方法和start()方法的联系
1.关联性：
    把需要处理的代码放到run()方法中，start()方法启动线程将自动调用run()方法，这个由java的内存机制规定的；
    并且run()方法必需是public访问权限，返回值类型为void

四、sleep()方法与yield()方法的共性和区别：
1.共性：
       都是Thread类中的静态方法，都会使得当前处于运行状态的线程放弃CPU
2.区别：
  (1). sleep()使当前线程暂停一段时间，给其它的线程运行的机会，而且是不考虑其它线程的优先级的，而且不释放资源锁；
       yeild()只会让位给优先级一样或者比它优先级高的线程，而且不能由用户指定暂停多长时间

  (2). 当线程执行了sleep()方法后，线程将转入到睡眠状态，直到时间结束；
       而执行yield()方法，直接转入到就绪状态，这些对线程的生命周期会造成影响的

  (3). sleep()方法需要抛出或捕获异常，因为线程在睡眠中可能被打断；
       然而yield()方法则没异常


