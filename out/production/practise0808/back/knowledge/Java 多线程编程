                                                Java 多线程编程
一、进程 与 线程
1.进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程
        进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位
2.线程：单个进程中执行中每个任务就是一个线程，线程是进程中执行运算的最小单位

3.线程完整的生命周期：
(1).新建状态：使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态
(2).就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态
(3).运行状态：如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态
    处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态
(4).阻塞状态：若一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态
    在睡眠时间已到或获得设备资源后可以重新进入就绪状态，可以分为三种：
    <1>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态；
    <2>同步阻塞：线程在获取 synchronized 同步锁失败    (因为同步锁被其他线程占用)；
    <3>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态；
       当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态
(5).死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态

4.三种创建线程的方法：
<1>.通过实现 Runnable 接口；
    1. 创建一个实现 Runnable 接口的类，只需要执行一个方法调用 run()
<2>.通过继承 Thread 类本身
    1. 该类继承 Thread 类，然后创建一个该类的实例。
    2. 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行
<3>.通过 Callable 和 Future 创建线程
    1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
    2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
    3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
    4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值


二、进程和线程两者的联系
1.不同点：
(1).一个线程只能属于一个进程，但是一个进程可以拥有多个线程
    多线程处理就是允许一个进程中在同一时刻执行多个任务
(2).线程是一种轻量级的进程，意味着线程的代价或开销比较小
(3).线程没有地址空间，线程包含在进程的地址空间中
(4).进程拥有的所有资源都属于线程，所有的线程共享进程的内存和资源
(5).但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程
    简而言之，一个程序至少有一个进程，一个进程至少有一个线程

2.相同点：
    进程和线程都有ID/寄存器组、状态和优先权、信息块，创建后都可更改自己的属性；
    都可与父进程共享资源、都不能直接访问其他无关进程或线程的资源


三、多线程主要概念
1.  线程同步和互斥
    <1>.线程同步：指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序
        ( 协同步调，按既定的先后次序进行运行 )
    <2>.线程互斥：指对于共享的进程系统资源，在各单个线程访问时的排它性
        ( 当存在多个线程同一时间访问某个共享资源时，只允许单一线程访问，其他线程需要等待，直到占用资源者释放该资源 )

2.  线程间通信：①同步 / ②while轮询的方式 / ③wait/notify机制 / ④管道通信
    ?<1>.线程上下文
    ?<2>.共享内存：多个线程需要访问同一个共享变量，获取锁（即获取了访问权限）立即先执行
    ?<3>.IPC通信：
    ?<4>.套接字(Socket)，不同的机器之间进行通信
    本人尚不明确是哪四种方式？？？？

3.  线程死锁：
    <1>.概念：指多个进程在运行过程中因争夺资源而照成的一种僵局
    <2>.原因：① 竞争资源    ② 进程间推进顺序非法
    <3>.必要条件：
        ① 互斥条件：
        ② 请求和保持条件：
        ③ 不剥夺条件：
        ④ 环路等待条件：

4.  线程控制：挂起、停止和恢复
    <1>.线程控制方法：
    ① join()方法：根据需要执行的先后顺序，先调用start()方法，然后调用join()方法
    ② 并发包Excutors中的newSingleThreadExecutor()：产生一个单线程的线程池，该线程池的底层原理是先进先出（FIFO）的队列

